<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CLUTCH</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        
        .title {
            font-size: clamp(48px, 15vw, 120px);
            font-weight: 900;
            letter-spacing: 0.2em;
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 40px #00ffff,
                0 0 80px #00ffff;
            margin-bottom: 10px;
        }
        
        .tagline {
            font-size: clamp(12px, 3vw, 18px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 50px;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .menu-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px 50px;
            color: #fff;
            font-size: clamp(16px, 4vw, 22px);
            font-weight: 700;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 280px;
            text-align: center;
        }
        
        .menu-btn:hover, .menu-btn:active {
            transform: scale(1.05);
        }
        
        .menu-btn.practice {
            border-color: #00ffff;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .menu-btn.practice:hover, .menu-btn.practice:active {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        .menu-btn.daily {
            border-color: #ff00ff;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }
        
        .menu-btn.daily:hover, .menu-btn.daily:active {
            background: rgba(255, 0, 255, 0.15);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
        }
        
        .menu-btn.daily.used {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .menu-subtitle {
            font-size: clamp(10px, 2.5vw, 13px);
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.1em;
            margin-top: 8px;
            font-weight: 400;
            text-transform: none;
        }
        
        .daily-status {
            margin-top: 20px;
            font-size: clamp(11px, 2.5vw, 14px);
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.1em;
        }
        
        .daily-status.completed {
            color: #22c55e;
        }
        
        .best-scores {
            margin-top: 40px;
            text-align: center;
        }
        
        .best-label {
            font-size: clamp(10px, 2.5vw, 12px);
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .best-value {
            font-size: clamp(14px, 3.5vw, 18px);
            color: #ff00ff;
            letter-spacing: 0.1em;
        }
        
        .countdown {
            font-size: clamp(80px, 25vw, 200px);
            font-weight: 900;
            color: #ff00ff;
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                0 0 80px #ff00ff;
        }
        
        .game-hud {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 20px;
        }
        
        .level-display {
            text-align: left;
        }
        
        .level-label {
            font-size: clamp(10px, 2.5vw, 14px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        
        .level-number {
            font-size: clamp(28px, 7vw, 42px);
            font-weight: 900;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
        }
        
        .mode-badge {
            font-size: clamp(8px, 2vw, 11px);
            padding: 3px 8px;
            border-radius: 4px;
            letter-spacing: 0.1em;
            margin-top: 5px;
            display: inline-block;
        }
        
        .mode-badge.practice {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
        }
        
        .mode-badge.daily {
            background: rgba(255, 0, 255, 0.2);
            color: #ff00ff;
        }
        
        .timer-display {
            text-align: right;
        }
        
        .timer-label {
            font-size: clamp(10px, 2.5vw, 14px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        
        .timer-value {
            font-size: clamp(28px, 7vw, 42px);
            font-weight: 900;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
        }
        
        .progress-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 400px;
        }
        
        .progress-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 4px;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .progress-label {
            text-align: center;
            margin-top: 8px;
            font-size: clamp(10px, 2.5vw, 13px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.1em;
        }
        
        /* Level Complete Screen */
        .level-complete {
            text-align: center;
        }
        
        .level-complete-title {
            font-size: clamp(20px, 5vw, 36px);
            color: #22c55e;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #22c55e;
        }
        
        .level-complete-number {
            font-size: clamp(60px, 18vw, 140px);
            font-weight: 900;
            color: #ff00ff;
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                0 0 80px #ff00ff;
            animation: levelPulse 0.5s ease-out;
        }
        
        .level-complete-next {
            font-size: clamp(12px, 3vw, 18px);
            color: rgba(255, 255, 255, 0.7);
            margin-top: 30px;
            letter-spacing: 0.2em;
        }
        
        @keyframes levelPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Death Screen */
        .death-screen {
            text-align: center;
        }
        
        .death-title {
            font-size: clamp(28px, 8vw, 60px);
            font-weight: 900;
            color: #ff0066;
            text-shadow: 
                0 0 10px #ff0066,
                0 0 20px #ff0066,
                0 0 40px #ff0066;
            margin-bottom: 20px;
        }
        
        .death-level {
            font-size: clamp(16px, 4vw, 26px);
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }
        
        .death-reached {
            font-size: clamp(42px, 11vw, 80px);
            font-weight: 900;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            margin-bottom: 10px;
        }
        
        .death-label {
            font-size: clamp(11px, 2.5vw, 16px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 30px;
        }
        
        .high-score {
            font-size: clamp(13px, 3.5vw, 18px);
            color: #00ffff;
            letter-spacing: 0.2em;
            margin-bottom: 15px;
        }
        
        .new-record {
            animation: flash 0.5s ease-in-out infinite;
        }
        
        .death-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 25px;
            pointer-events: auto;
        }
        
        .death-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px 40px;
            color: #fff;
            font-size: clamp(14px, 3.5vw, 18px);
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .death-btn:hover, .death-btn:active {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.03);
        }
        
        .death-btn.retry {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .death-btn.menu {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Daily complete */
        .daily-complete {
            text-align: center;
        }
        
        .daily-complete-title {
            font-size: clamp(18px, 4.5vw, 28px);
            color: #22c55e;
            letter-spacing: 0.2em;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #22c55e;
        }
        
        .daily-result {
            font-size: clamp(48px, 14vw, 100px);
            font-weight: 900;
            color: #ff00ff;
            text-shadow: 0 0 30px #ff00ff;
            margin-bottom: 10px;
        }
        
        .daily-date {
            font-size: clamp(12px, 3vw, 16px);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.15em;
            margin-bottom: 30px;
        }
        
        .share-btn {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            border: none;
            border-radius: 10px;
            padding: 15px 40px;
            color: #000;
            font-size: clamp(14px, 3.5vw, 18px);
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            pointer-events: auto;
            margin-bottom: 20px;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .hidden {
            display: none !important;
        }
        
        .combo-display {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(22px, 5.5vw, 36px);
            font-weight: 900;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        .combo-display.show {
            opacity: 1;
            animation: comboPopup 0.3s ease-out;
        }
        
        @keyframes comboPopup {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="ui">
        <!-- Title/Menu Screen -->
        <div id="title-screen">
            <div class="title">CLUTCH</div>
            <div class="tagline">How far can you go?</div>
            <div class="menu-buttons">
                <button class="menu-btn practice" onclick="startMode('practice')">
                    Practice Mode
                    <div class="menu-subtitle">Unlimited attempts</div>
                </button>
                <button class="menu-btn daily" id="daily-btn" onclick="startMode('daily')">
                    Daily Challenge
                    <div class="menu-subtitle">One shot. Prove yourself.</div>
                </button>
            </div>
            <div class="daily-status" id="daily-status"></div>
            <div class="best-scores">
                <div class="best-label">Best Level</div>
                <div class="best-value" id="best-level">Level 1</div>
            </div>
        </div>
        
        <div id="countdown-screen" class="hidden">
            <div class="countdown" id="countdown-number">3</div>
        </div>
        
        <div id="game-ui" class="hidden">
            <div class="game-hud">
                <div class="level-display">
                    <div class="level-label">Level</div>
                    <div class="level-number" id="level-num">1</div>
                    <div class="mode-badge practice" id="mode-badge">PRACTICE</div>
                </div>
                <div class="timer-display">
                    <div class="timer-label">Time</div>
                    <div class="timer-value" id="timer">0.0</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-track">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-label" id="progress-label">0 / 15 seconds</div>
            </div>
            <div class="combo-display" id="combo-display">x2 COMBO!</div>
        </div>
        
        <div id="level-complete-screen" class="hidden">
            <div class="level-complete">
                <div class="level-complete-title">Level Complete!</div>
                <div class="level-complete-number" id="completed-level">1</div>
                <div class="level-complete-next">Get ready...</div>
            </div>
        </div>
        
        <div id="death-screen" class="hidden">
            <div class="death-screen">
                <div class="death-title">CLUTCH</div>
                <div class="death-level">You reached</div>
                <div class="death-reached" id="final-level">Level 1</div>
                <div class="death-label">Restarting from Level 1</div>
                <div class="high-score" id="high-score">BEST: Level 1</div>
                <div class="death-buttons">
                    <button class="death-btn retry" onclick="retryGame()">Try Again</button>
                    <button class="death-btn menu" onclick="backToMenu()">Menu</button>
                </div>
            </div>
        </div>
        
        <div id="daily-complete-screen" class="hidden">
            <div class="daily-complete">
                <div class="daily-complete-title">Daily Challenge Complete!</div>
                <div class="daily-result" id="daily-result">Level 5</div>
                <div class="daily-date" id="daily-date">February 17, 2026</div>
                <button class="share-btn" onclick="shareDaily()">ðŸ“¤ Share Result</button>
                <button class="death-btn menu" onclick="backToMenu()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const titleScreen = document.getElementById('title-screen');
        const countdownScreen = document.getElementById('countdown-screen');
        const countdownNumber = document.getElementById('countdown-number');
        const gameUI = document.getElementById('game-ui');
        const levelNum = document.getElementById('level-num');
        const modeBadge = document.getElementById('mode-badge');
        const timerDisplay = document.getElementById('timer');
        const progressFill = document.getElementById('progress-fill');
        const progressLabel = document.getElementById('progress-label');
        const comboDisplay = document.getElementById('combo-display');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const completedLevel = document.getElementById('completed-level');
        const deathScreen = document.getElementById('death-screen');
        const finalLevel = document.getElementById('final-level');
        const highScoreDisplay = document.getElementById('high-score');
        const dailyCompleteScreen = document.getElementById('daily-complete-screen');
        const dailyResult = document.getElementById('daily-result');
        const dailyDate = document.getElementById('daily-date');
        const dailyBtn = document.getElementById('daily-btn');
        const dailyStatus = document.getElementById('daily-status');
        const bestLevelDisplay = document.getElementById('best-level');
        
        // Game state
        let gameState = 'title';
        let gameMode = 'practice'; // 'practice' or 'daily'
        let currentLevel = 1;
        let levelTime = 0;
        let highestLevel = parseInt(localStorage.getItem('clutch-highest-level')) || 1;
        let lastTime = 0;
        let deltaTime = 0;
        let combo = 0;
        let comboTimer = 0;
        
        // Daily challenge
        let dailySeed = 0;
        let dailyCompleted = false;
        let dailyBestLevel = 0;
        
        // Level definitions - FAST & FURIOUS, tons of gaps
        const levels = [
            null,
            { duration: 15, ringSpeed: 140, spawnInterval: 1.0, gapSize: 0.32, maxGaps: 5, rotationSpeed: 1.6, name: "Warm Up" },
            { duration: 18, ringSpeed: 160, spawnInterval: 0.9, gapSize: 0.30, maxGaps: 5, rotationSpeed: 1.7, name: "Getting Started" },
            { duration: 22, ringSpeed: 180, spawnInterval: 0.8, gapSize: 0.28, maxGaps: 6, rotationSpeed: 1.8, name: "Finding Rhythm" },
            { duration: 26, ringSpeed: 200, spawnInterval: 0.75, gapSize: 0.26, maxGaps: 6, rotationSpeed: 1.9, reverseChance: 0.2, name: "Reversal" },
            { duration: 30, ringSpeed: 220, spawnInterval: 0.7, gapSize: 0.24, maxGaps: 7, rotationSpeed: 2.0, reverseChance: 0.3, name: "Chaos" },
            { duration: 32, ringSpeed: 240, spawnInterval: 0.65, gapSize: 0.22, maxGaps: 7, rotationSpeed: 2.1, reverseChance: 0.4, doubleRing: true, name: "Double Trouble" },
            { duration: 34, ringSpeed: 260, spawnInterval: 0.6, gapSize: 0.20, maxGaps: 8, rotationSpeed: 2.2, reverseChance: 0.4, doubleRing: true, name: "Nightmare" },
            { duration: 36, ringSpeed: 280, spawnInterval: 0.55, gapSize: 0.19, maxGaps: 8, rotationSpeed: 2.3, reverseChance: 0.5, doubleRing: true, shiftingGaps: true, name: "Impossible" },
            { duration: 38, ringSpeed: 300, spawnInterval: 0.5, gapSize: 0.18, maxGaps: 9, rotationSpeed: 2.4, reverseChance: 0.5, doubleRing: true, shiftingGaps: true, name: "Legendary" },
            { duration: 40, ringSpeed: 320, spawnInterval: 0.45, gapSize: 0.17, maxGaps: 10, rotationSpeed: 2.5, reverseChance: 0.6, doubleRing: true, shiftingGaps: true, name: "CLUTCH MASTER" }
        ];
        
        const levelThemes = [
            null,
            { primary: '#00ffff', secondary: '#ff00ff', bg: '#0a0a0a' },
            { primary: '#00ff88', secondary: '#ff00ff', bg: '#0a0a0a' },
            { primary: '#00ffff', secondary: '#ff8800', bg: '#0a0808' },
            { primary: '#ff00ff', secondary: '#00ffff', bg: '#080a0a' },
            { primary: '#ffff00', secondary: '#ff0066', bg: '#0a0a08' },
            { primary: '#ff0066', secondary: '#00ffff', bg: '#0a0808' },
            { primary: '#8800ff', secondary: '#00ff88', bg: '#08080a' },
            { primary: '#ff00ff', secondary: '#ffff00', bg: '#0a080a' },
            { primary: '#00ffff', secondary: '#ff0066', bg: '#080a0a' },
            { primary: '#ffffff', secondary: '#ff00ff', bg: '#050505' }
        ];
        
        let width, height, centerX, centerY, minDim;
        
        const player = {
            angle: 0,
            orbitRadius: 0,
            baseOrbitRadius: 0,
            rotationSpeed: 1.5,
            rotationDirection: 1,
            x: 0,
            y: 0,
            radius: 0,
            dashing: false,
            dashSpeed: 0,
            dashTargetRadius: 0,
            dashProgress: 0,
            returnSpeed: 8,
            trail: []
        };
        
        let rings = [];
        let ringSpawnTimer = 0;
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let particles = [];
        let rng = Math.random;
        
        // Seeded RNG for daily challenge
        function seededRandom(seed) {
            let s = seed;
            return function() {
                s = Math.sin(s * 9999) * 10000;
                return s - Math.floor(s);
            };
        }
        
        function getTodayString() {
            const d = new Date();
            return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        }
        
        function getTodaySeed() {
            const str = getTodayString();
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }
        
        function checkDailyStatus() {
            const today = getTodayString();
            const lastDaily = localStorage.getItem('clutch-daily-date');
            const lastResult = parseInt(localStorage.getItem('clutch-daily-result')) || 0;
            
            if (lastDaily === today) {
                dailyCompleted = true;
                dailyBestLevel = lastResult;
                dailyBtn.classList.add('used');
                dailyStatus.textContent = `Today's result: Level ${lastResult}`;
                dailyStatus.classList.add('completed');
            } else {
                dailyCompleted = false;
                dailyBestLevel = 0;
                dailyBtn.classList.remove('used');
                dailyStatus.textContent = "Today's challenge awaits!";
                dailyStatus.classList.remove('completed');
            }
        }
        
        function getLevelConfig() {
            const idx = Math.min(currentLevel, levels.length - 1);
            return levels[idx];
        }
        
        function getTheme() {
            const idx = Math.min(currentLevel, levelThemes.length - 1);
            return levelThemes[idx];
        }
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
            minDim = Math.min(width, height);
            player.baseOrbitRadius = minDim * 0.12;
            player.orbitRadius = player.baseOrbitRadius;
            player.radius = minDim * 0.025;
        }
        
        resize();
        window.addEventListener('resize', resize);
        
        function handleInput(e) {
            e.preventDefault();
            if (gameState === 'playing' && !player.dashing) {
                startDash();
            }
        }
        
        canvas.addEventListener('touchstart', handleInput);
        canvas.addEventListener('mousedown', handleInput);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });
        
        function startMode(mode) {
            gameMode = mode;
            
            if (mode === 'daily') {
                if (dailyCompleted) return;
                dailySeed = getTodaySeed();
                rng = seededRandom(dailySeed);
            } else {
                rng = Math.random;
            }
            
            currentLevel = 1;
            startCountdown();
        }
        
        function startCountdown() {
            gameState = 'countdown';
            titleScreen.classList.add('hidden');
            deathScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            dailyCompleteScreen.classList.add('hidden');
            countdownScreen.classList.remove('hidden');
            
            let count = 3;
            countdownNumber.textContent = count;
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                } else {
                    clearInterval(countInterval);
                    startLevel();
                }
            }, 700);
        }
        
        function startLevel() {
            gameState = 'playing';
            countdownScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            
            levelTime = 0;
            rings = [];
            particles = [];
            ringSpawnTimer = 0;
            combo = 0;
            comboTimer = 0;
            
            const config = getLevelConfig();
            player.rotationSpeed = config.rotationSpeed;
            player.rotationDirection = 1;
            player.angle = 0;
            player.orbitRadius = player.baseOrbitRadius;
            player.dashing = false;
            player.trail = [];
            
            modeBadge.textContent = gameMode === 'daily' ? 'DAILY' : 'PRACTICE';
            modeBadge.className = 'mode-badge ' + gameMode;
            
            updateHUD();
        }
        
        function completeLevel() {
            gameState = 'levelComplete';
            gameUI.classList.add('hidden');
            levelCompleteScreen.classList.remove('hidden');
            completedLevel.textContent = currentLevel;
            
            const theme = getTheme();
            for (let i = 0; i < 40; i++) {
                const angle = rng() * Math.PI * 2;
                const speed = 100 + rng() * 250;
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.5,
                    color: rng() > 0.5 ? theme.primary : theme.secondary,
                    radius: 4 + rng() * 8
                });
            }
            
            currentLevel++;
            
            setTimeout(() => {
                if (gameState === 'levelComplete') {
                    startCountdown();
                }
            }, 2000);
        }
        
        function startDash() {
            player.dashing = true;
            player.dashProgress = 0;
            player.dashTargetRadius = minDim * 0.45;
            player.dashSpeed = 12;
            
            const theme = getTheme();
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (rng() - 0.5) * 200,
                    vy: (rng() - 0.5) * 200,
                    life: 1,
                    color: theme.primary,
                    radius: player.radius * 0.3
                });
            }
        }
        
        function spawnRing() {
            const config = getLevelConfig();
            const theme = getTheme();
            const numGaps = 1 + Math.floor(rng() * config.maxGaps);
            const gaps = [];
            const gapSize = Math.PI * config.gapSize + rng() * Math.PI * 0.05;
            
            for (let i = 0; i < numGaps; i++) {
                let gapAngle, valid = false, attempts = 0;
                while (!valid && attempts < 50) {
                    gapAngle = rng() * Math.PI * 2;
                    valid = true;
                    for (const g of gaps) {
                        const diff = Math.abs(gapAngle - g.angle);
                        if (Math.min(diff, Math.PI * 2 - diff) < gapSize * 2) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                }
                if (valid) {
                    gaps.push({
                        angle: gapAngle,
                        size: gapSize,
                        shifting: config.shiftingGaps && rng() > 0.7,
                        shiftSpeed: (rng() - 0.5) * 2
                    });
                }
            }
            
            rings.push({
                radius: minDim * 0.6,
                gaps: gaps,
                color: rng() > 0.3 ? theme.primary : theme.secondary,
                thickness: minDim * 0.015,
                passed: false
            });
            
            if (config.doubleRing && rng() > 0.65) {
                setTimeout(() => { if (gameState === 'playing') spawnRing(); }, 250);
            }
            
            if (config.reverseChance && rng() < config.reverseChance * 0.08) {
                player.rotationDirection *= -1;
                screenShake.intensity = 8;
            }
        }
        
        function showCombo() {
            combo++;
            if (combo >= 2) {
                comboDisplay.textContent = `x${combo} COMBO!`;
                comboDisplay.classList.add('show');
                comboTimer = 1.2;
            }
        }
        
        function die() {
            const reachedLevel = currentLevel;
            
            if (gameMode === 'daily') {
                // Daily mode - game over, show result
                gameState = 'dailyDone';
                gameUI.classList.add('hidden');
                dailyCompleteScreen.classList.remove('hidden');
                dailyResult.textContent = `Level ${reachedLevel}`;
                
                const d = new Date();
                dailyDate.textContent = d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                
                // Save daily result
                localStorage.setItem('clutch-daily-date', getTodayString());
                localStorage.setItem('clutch-daily-result', reachedLevel);
                dailyCompleted = true;
                dailyBestLevel = reachedLevel;
                
            } else {
                // Practice mode - can retry
                gameState = 'dead';
                gameUI.classList.add('hidden');
                deathScreen.classList.remove('hidden');
                finalLevel.textContent = `Level ${reachedLevel}`;
                
                const isNewRecord = reachedLevel > highestLevel;
                if (isNewRecord) {
                    highestLevel = reachedLevel;
                    localStorage.setItem('clutch-highest-level', highestLevel);
                }
                
                highScoreDisplay.textContent = `BEST: Level ${highestLevel}`;
                highScoreDisplay.classList.toggle('new-record', isNewRecord);
            }
            
            screenShake.intensity = 25;
            
            const theme = getTheme();
            for (let i = 0; i < 25; i++) {
                const angle = rng() * Math.PI * 2;
                const speed = 100 + rng() * 250;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: theme.primary,
                    radius: player.radius * (0.2 + rng() * 0.5)
                });
            }
            
            currentLevel = 1;
        }
        
        function retryGame() {
            resetGame();
            startCountdown();
        }
        
        function backToMenu() {
            gameState = 'title';
            resetGame();
            deathScreen.classList.add('hidden');
            dailyCompleteScreen.classList.add('hidden');
            titleScreen.classList.remove('hidden');
            checkDailyStatus();
            bestLevelDisplay.textContent = `Level ${highestLevel}`;
        }
        
        function shareDaily() {
            const text = `CLUTCH Daily Challenge\n${new Date().toLocaleDateString()}\n\nðŸŽ® Level ${dailyBestLevel}\n\nCan you beat my score?`;
            
            if (navigator.share) {
                navigator.share({ text: text });
            } else {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Result copied to clipboard!');
                });
            }
        }
        
        function resetGame() {
            player.angle = 0;
            player.orbitRadius = player.baseOrbitRadius;
            player.dashing = false;
            player.trail = [];
            player.rotationDirection = 1;
            rings = [];
            particles = [];
            screenShake = { x: 0, y: 0, intensity: 0 };
            combo = 0;
            rng = gameMode === 'daily' ? seededRandom(dailySeed) : Math.random;
        }
        
        function updateHUD() {
            const config = getLevelConfig();
            levelNum.textContent = currentLevel;
            timerDisplay.textContent = levelTime.toFixed(1);
            const progress = (levelTime / config.duration) * 100;
            progressFill.style.width = `${Math.min(progress, 100)}%`;
            progressLabel.textContent = `${levelTime.toFixed(1)} / ${config.duration}s`;
        }
        
        function checkCollision() {
            const playerAngle = player.angle;
            const playerRadius = player.orbitRadius;
            
            for (let i = rings.length - 1; i >= 0; i--) {
                const ring = rings[i];
                
                if (ring.radius <= player.baseOrbitRadius * 0.3) {
                    if (!ring.passed) { die(); return; }
                    rings.splice(i, 1);
                    continue;
                }
                
                if (player.dashing && !ring.passed) {
                    const crossedRing = playerRadius > ring.radius && playerRadius < ring.radius + minDim * 0.15;
                    
                    if (crossedRing && playerRadius > player.baseOrbitRadius) {
                        let inGap = false;
                        let normAngle = playerAngle % (Math.PI * 2);
                        if (normAngle < 0) normAngle += Math.PI * 2;
                        
                        for (const gap of ring.gaps) {
                            let diff = Math.abs(normAngle - gap.angle);
                            if (diff > Math.PI) diff = Math.PI * 2 - diff;
                            if (diff < gap.size / 2) { inGap = true; break; }
                        }
                        
                        if (inGap) {
                            const theme = getTheme();
                            for (let j = 0; j < 16; j++) {
                                const pAngle = (j / 16) * Math.PI * 2;
                                particles.push({
                                    x: centerX + Math.cos(pAngle) * ring.radius,
                                    y: centerY + Math.sin(pAngle) * ring.radius,
                                    vx: Math.cos(pAngle) * (40 + rng() * 80),
                                    vy: Math.sin(pAngle) * (40 + rng() * 80),
                                    life: 0.7,
                                    color: ring.color,
                                    radius: 3 + rng() * 4
                                });
                            }
                            showCombo();
                            rings.splice(i, 1);
                        } else {
                            die();
                            return;
                        }
                    }
                }
            }
        }
        
        function update(timestamp) {
            if (!lastTime) lastTime = timestamp;
            deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= 0.9;
                if (screenShake.intensity < 0.5) screenShake.intensity = 0;
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= deltaTime * 1.5;
                p.vx *= 0.98;
                p.vy *= 0.98;
                if (p.life <= 0) particles.splice(i, 1);
            }
            
            if (comboTimer > 0) {
                comboTimer -= deltaTime;
                if (comboTimer <= 0) {
                    comboDisplay.classList.remove('show');
                    combo = 0;
                }
            }
            
            if (gameState !== 'playing') return;
            
            const config = getLevelConfig();
            levelTime += deltaTime;
            updateHUD();
            
            if (levelTime >= config.duration) {
                completeLevel();
                return;
            }
            
            ringSpawnTimer += deltaTime;
            if (ringSpawnTimer >= config.spawnInterval) {
                spawnRing();
                ringSpawnTimer = 0;
            }
            
            if (player.dashing) {
                player.dashProgress += deltaTime * player.dashSpeed;
                if (player.dashProgress < 1) {
                    const eased = 1 - Math.pow(1 - player.dashProgress, 3);
                    player.orbitRadius = player.baseOrbitRadius + (player.dashTargetRadius - player.baseOrbitRadius) * eased;
                    player.trail.push({ x: player.x, y: player.y, alpha: 1 });
                } else {
                    player.orbitRadius -= player.returnSpeed * minDim * deltaTime;
                    if (player.orbitRadius <= player.baseOrbitRadius) {
                        player.orbitRadius = player.baseOrbitRadius;
                        player.dashing = false;
                    }
                }
            } else {
                player.angle += player.rotationSpeed * player.rotationDirection * deltaTime;
                if (player.angle > Math.PI * 2) player.angle -= Math.PI * 2;
                if (player.angle < 0) player.angle += Math.PI * 2;
            }
            
            player.x = centerX + Math.cos(player.angle) * player.orbitRadius;
            player.y = centerY + Math.sin(player.angle) * player.orbitRadius;
            
            for (let i = player.trail.length - 1; i >= 0; i--) {
                player.trail[i].alpha -= deltaTime * 5;
                if (player.trail[i].alpha <= 0) player.trail.splice(i, 1);
            }
            
            for (const ring of rings) {
                ring.radius -= config.ringSpeed * deltaTime;
                for (const gap of ring.gaps) {
                    if (gap.shifting) gap.angle += gap.shiftSpeed * deltaTime;
                }
            }
            rings = rings.filter(r => r.radius > 0);
            
            checkCollision();
        }
        
        function draw() {
            const theme = getTheme();
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            ctx.fillStyle = theme.bg;
            ctx.fillRect(-screenShake.x, -screenShake.y, width, height);
            
            // Center glow
            const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, minDim * 0.15);
            grad.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, minDim * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            if (gameState === 'playing' || gameState === 'countdown') {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, player.baseOrbitRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            for (const ring of rings) {
                ctx.lineWidth = ring.thickness;
                for (let a = 0; a < Math.PI * 2; a += 0.05) {
                    let inGap = false;
                    for (const gap of ring.gaps) {
                        let diff = Math.abs(a - gap.angle);
                        diff = Math.min(diff, Math.PI * 2 - diff);
                        if (diff < gap.size / 2) { inGap = true; break; }
                    }
                    if (!inGap) {
                        ctx.strokeStyle = ring.color;
                        ctx.shadowColor = ring.color;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, ring.radius, a, a + 0.06);
                        ctx.stroke();
                    }
                }
                ctx.shadowBlur = 0;
            }
            
            for (const p of particles) {
                ctx.globalAlpha = Math.min(p.life, 1);
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * Math.min(p.life, 1), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            for (const t of player.trail) {
                ctx.globalAlpha = t.alpha * 0.5;
                ctx.fillStyle = theme.primary;
                ctx.beginPath();
                ctx.arc(t.x, t.y, player.radius * t.alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            if (gameState === 'playing' || gameState === 'countdown') {
                const pg = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 2.5);
                pg.addColorStop(0, theme.primary + '80');
                pg.addColorStop(1, theme.primary + '00');
                ctx.fillStyle = pg;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = theme.primary;
                ctx.shadowColor = theme.primary;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(player.x - player.radius * 0.3, player.y - player.radius * 0.3, player.radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Init
        checkDailyStatus();
        bestLevelDisplay.textContent = `Level ${highestLevel}`;
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
